# 性能优化专题

## 缓存

当使用浏览器的后退按钮时会发现页面加载速度特别快，这就是浏览器缓存的力量。

### 什么是缓存

> 当我们在第一次访问网站时，浏览器会把该网站的图片数据下载到电脑上，如果我们再次访问该网站，浏览器就直接从本地读取资源而不是再次去服务器请求，这就是浏览器缓存。

### 缓存的好处

+ 减轻服务器的压力，不用每次都去服务器读取。
+ 提升性能，从本地读取资源比去服务器请求快的多。
+ 减少带宽消耗，当我们使用缓存时，只会产生很小的网络消耗，至于为什么打开本地资源也会产生网络消耗，下面会有说明。

### web缓存的类型

> 缓存类型主要有：数据库缓存、CDN缓存、代理服务器缓存、浏览器缓存。前端主要关注浏览器缓存。

### 浏览器缓存

> 缓存分为强缓存和协商缓存，强缓存不过服务器，协商缓存需要过服务器。协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级强于协商缓存。当执行强缓存时，如果缓存命中，则直接使用缓存中的数据，不再进行缓存协商。

> 缓存位置一般有四个：Service worker, memory cache, disk cache, push catch

#### 强缓存

强缓存是指当浏览器访问url时，不会向服务器发送请求，直接使用缓存中的数据，而且响应状态码是200。

我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中expires、pragma或者cache-control字段，代表这是强缓存，浏览器就会把资源缓存在memory cache 或 disk cache中。

1. Expires(HTTP1.0)：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。
`Expires响应头的缺点是使用绝对时间，如果服务器与客户端时间不一致，那么就导致缓存命中偏差。`

2. pragma(HTTP1.0)：HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存，它与Cache-Control=no-cache效果一样。pragma禁用缓存，如果pragma=no-cache与expires时间之内同时存在，则pragma优先级更高。服务端如果添加响应头pragma:no-cache会与浏览器f5刷新差不多。

3. Cache-Control(HTTP1.1)：有很多属性，不同的属性代表的意义也不同：
+ private：客户端可以缓存
+ public：客户端和代理服务器都可以缓存
+ max-age=t：缓存将在t秒后失效
+ **no-cache：使用协商缓存来验证缓存有效性**
+ no-store：所有内容都不进行缓存

请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。Cache-Control使用了max-age相对时间，解决了expires的问题。

#### 协商缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

如何设置协商缓存？

**使用Last-Modified / If-Modified-Since缓存标识**

Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。
服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

**使用Etag/If-Match/If-Non-Match

Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）
If-Match：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改
If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

+ 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）
+ F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since
+ Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作

### 缓存方案

对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
对于代码文件来说，通常使用 Cache-Control: max-age=31536000（一年） 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

目前大多采用这种缓存方案
html:协商缓存
css,image,js: 强缓存，文件名带hash值
