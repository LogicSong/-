## 从输入URL到页面呈现发生了什么？

### 网络请求
#### 1.构建请求
浏览器会构建请求行:
`GET / http/1.1`
#### 2.查找强缓存
先检查强缓存，如果命中直接使用，否则进入下一步。

#### 3.DNS解析
由于我们输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做DNS（域名系统）。得到具体 IP 的过程就是DNS解析。
当然，值得注意的是，浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析。
另外，如果不指定端口的话，默认采用对应 IP 的 80 端口。

>需要注意的是DNS解析时还要考虑目标网站是否使用了CDN(内容分发网络)技术，此处参考性能优化篇的CDN章节。
#### 4.建立TCP连接
> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

+ 通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。
+ 进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。
+ 断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。

可见，TCP 连接是通过什么手段来保证数据传输的可靠性，一是三次握手确认连接，二是数据包校验保证数据到达接收方，三是通过四次挥手断开连接。
#### 5.发送 HTTP 请求
TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:**请求行、请求头和请求体**。

注意：请求体只有在POST方法下存在，GET请求的请求参数存在于请求行的请求URL中。
#### 6.服务器处理请求并返回 HTTP 报文
跟请求部分类似，网络响应具有三个部分:响应行、响应头和响应体。
响应行如下：
`http/1.1 200 ok`

从HTTP/1.1起，浏览器默认都开启了connection:Keep-Alive请求头，保持连接特性，客户端和服务器都能选择随时关闭连接，则请求头中为connection:close。简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。但是Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

#### 7.浏览器解析渲染页面
![](./img/浏览器渲染.png)

浏览器解析渲染页面分为一下五个步骤：
+ 根据 HTML 解析出 DOM 树
+ 根据 CSS 解析生成 CSS 规则树
+ 结合 DOM 树和 CSS 规则树，生成渲染树
+ 根据渲染树计算每一个节点的信息
+ 根据计算好的信息绘制页面

##### 根据 HTML 解析 DOM 树

+ 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。
+ 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

##### 根据 CSS 解析生成 CSS 规则树

+ 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。
+ 浏览器在 CSS 规则树生成之前不会进行渲染。

##### 结合 DOM 树和 CSS 规则树，生成渲染树

- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。
- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

##### 根据渲染树计算每一个节点的信息（布局）

- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
- 回流：**回流的意思是重新布局**。在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

##### 根据计算好的信息绘制页面

+ 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
+ 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
+ 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

#### 断开TCP连接

当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。


## 浏览器的回流(重排)与重绘(Reflow & Repaint)

#### 回流

DOM树和CSSOM树结合后的渲染树后，将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。回流一定伴随重绘。

会导致回流的操作：
- 页面首次渲染
- 添加或者删除可见的DOM元素
- 元素位置改变
- 元素尺寸改变——边距、填充、边框、高度和宽度
- 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变
- 浏览器窗口尺寸改变——resize事件发生时

#### 重绘
通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

只是样式的变化，不会引起DOM树变化，页面布局变化的行为叫重绘，且重绘不一定会便随回流。
#### 如何减少重排重绘？
- 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。
- 不要经常访问会引起浏览器flush队列的属性
- 让要操作的元素进行”离线处理”，处理完后一起更新：1. 使用DocumentFragment进行缓存操作,引发一次回流和重绘；2.使用display:none技术，只引发两次回流和重绘；

## 浏览器的本地存储

### Cookie

#### Cookie的作用

http是无状态的，为了解决无状态带来的麻烦，浏览器用cookie管理状态

#### 原理

第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，浏览器接收到响应后将cookie保存到本地；在浏览器第二次发请求的时候，浏览器会自动把cookie带过去，服务端可以用来辨别用户身份，当然服务器也可以修改cookie内容。

#### 不可跨域性

每个cookie都会绑定单一的域名

#### cookie的属性

- name:一个域名下可以绑定多个cookie，每一个cookie都有自己的名称，如果重复（domian和path字段一致的前提下），则后值覆盖前值。
- value:该cookie的值。需要注意的是：由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户到来麻烦，考虑服务器的兼容性，任何存储cookie的数据都应该被URL编码（window.encodeURLComponent())。
- domain:cookie绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，还有值得注意的点，统一个域名下的二级域名也是不可以交换使用cookie的。
- path:该cookie能匹配到的web路由。注意：当你路径设置成/blog的时候，其实它会给/blog、/blogabc等等的绑定cookie
- cookie的有效期：expires：值为过期时间或者session，后者的意思是会话有效。Max-Age：时间戳，是以秒为单位的，Max-Age为正数时，cookie会在Max-Age秒之后，被删除，当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失，当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。
- secure：当这个属性设置为true时，此cookie只会在https和ssl等安全协议下传输
- **HttpOnly**：如果这个属性设置为true，就不能通过js脚本(document.cookie)来获取cookie的值，**能有效的防止xss攻击**

#### cookie数据大小不能超过4k

### sessionStorage/localStorage/cookie之间的区别

- cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
- cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
- cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地
