# Javascript基础
`注：主要参考红宝书第四版总结而成`
## 变量、作用域与内存
### 变量
+ js变量为松散类型
+ 可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个（原始值）值构成的对象。
+ 原始值包含6种类型：undefined,null,number,string,boolean,symbol(es6新增)；引用值就是Object。
+ typeof操作符可以用来判断原始值的类型，需要注意的是null的操作结果为object。此外，typeof操作符对判断引用值的意义不大，应该使用instanceof操作符
### 执行上下文与作用域
+ 执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个 ***关联的变量对象（variable object）*** ，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数
+ 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。
+ 上下文中的代码在执行的时候，会创建 ***变量对象*** 的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的 ***变量对象*** 始终位于作用域链的最前端。如果上下文是函数，则其 **活动对象（activation object）** 用作 ***变量对象*** 。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

```
注：函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。
```
### 作用域链增强
虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：
+ try/catch 语句的 catch 块
+ with 语句

这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
### 变量声明
ES6 之后，JavaScript 的变量声明经历了翻天覆地的变化。直到 ECMAScript 5.1，var 都是声明变量的唯一关键字。ES6 不仅增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var成为首选。
1. var. 在使用var声明变量时，该变量会被自动添加到最接近的上下文中。在函数中，最接近的上下文就是函数的局部上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文（严格模式下会报错）。
var声明会被拿到函数或者全局作用域的顶部，位于当前作用域所有代码之前。这个现象叫做变量提升（hoisting)。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。
2. let. ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，**这也是 JavaScript 中的新概念**。此处说明块级作用域是es6新增的。let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。
3. const. const声明关键字同样是ea6新增的，使用const声明变量时必须同时进行初始化，并且声明后不能对值进行更改，其实也就是常量。注意：const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败。
```
const的被提倡使用的原因：JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找，V8引擎就有这种优化。
```
### 垃圾回收
1. 垃圾回收的两种方法：1、标记清理（常用），2、引用计数（不常用）
2. 引用计数的缺点：循环引用
3. 基于垃圾回收机制的内存管理及性能优化：
+ 如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。
+ 使用let与const代替var。因为 const和let都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
+ 隐藏类和删除操作
4. 内存泄漏：a)意外声明全局变量：只要window不被清除，该变量就一直存在；b)闭包

## 基本引用类型
### Date
略。Date类型比较简单，使用场景也很固定，不浪费时间。
### RegExp正则表达式
语法：` let expression = /pattern/flag`
#### 匹配模式标记flag
1. g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
2. i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
3. m：多行模式，表示查找到一行文本末尾时会继续查找。
4. y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
5. u：Unicode 模式，启用 Unicode 匹配。
6. s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。
#### 正则表达式中的元字符
`( [ { \ ^ $ | ) ] } ? * + .`
元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠\来转义。
#### 使用构造函数创建正则表达式
`let expression = new RegExp("pattern", flag);`
注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，在正则表达式字符串中则要写成\\\\）。
#### RegExp的实例方法
1. exec()：该方法主要用于配合捕获组使用，方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。
2. test()：接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。
### 原始值包装类型
为了方便操作原始值，ECMAScript 提供了 ***3 种特殊的引用类型：Boolean、Number 和 String***。
每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。以字符串为例，在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：
1. 创建一个 String 类型的实例；
2. 调用实例上的特定方法；
3. 销毁实例。（将其置为null）
boolean与number类型也是一样。
## 集合引用类型
### Object

### Array
`数组在面试中还是比较重要的`
+ 检测数组：Array.isArray()
+ 迭代器方法：keys()、values()和entries()
+ from()和of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。
+ 栈、队列方法：push(),pop(),shift()。
+ concat()、slice()、splice()
+ 搜索方法：ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()
+ 断言方法：find()和 findIndex()
+ 归并方法：reduce()、reduceRight()
+ 迭代方法:
1. map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
2. forEach()：对数组每一项都运行传入的函数，没有返回值。
3. filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。
4. every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。
5. some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。

### Map
#### Map与Object的不同点
1. Object的键只能使用字符串、数值或Symbol，Map则可以使用任何JS数据类型来作为键。Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的。
```
注意 SameValueZero 是 ECMAScript 规范新增的相等性比较算法。关于 ECMAScript 的相等性比较，可以参考 MDN 文档中的文章“Equality Comparisons and Sameness”。
```
2. Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过 entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器。
3. 内存占用：不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。
4. 插入性能：向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。
5. 查找速度：与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。
6. 删除性能：使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。
**综合来看，map性能优于object**
#### Map的常用API
1. set()
2. get()
3. has()
4. delete()
5. clear()
6. keys()
7. values()
8. entries()

### WeakMap
WeakMap与Map的差异点：
1. WeakMap中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。
2. WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。
3. 不可迭代。因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。
`除了以上3点，WeakMap与Map的API基本一致`
```
WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。
```

### Set与WeakSet
ECMAScript 6 新增的 Set 是一种新集合类型，在很多方面都像是加强的 Map，它们的大多数 API 和行为都是共有的。
WeakSet与Set的关系和WeakMap与Map的关系一致

## 迭代器（Iterator）与生成器（Generator)
迭代器与生成器都是ES6新增的特性，使用这两个特性，能够更清晰、高效、方便地实现迭代。
### 迭代器模式
迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。
#### 可迭代协议
实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。
### 生成器
1. 生成器的形式是一个函数，函数名称前面加一个星（*）表示它是一个生成器。
2. 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。
3. next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。
4. yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行。yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误。
5. 除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。
```
箭头函数不能用来定义生成器函数。
```
## 对象、类与面向对象编程
ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。
### 理解对象
#### 对象的创建方式
```
let obj = New Object();
let obj = {};
```
#### 属性的类型
属性分两种：数据属性和访问器属性。
##### 数据属性
数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4
个特性描述它们的行为。
1. Configurable：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误。
2. Enumerable：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。
3. Writable：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。
4. Value：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。
要修改属性的默认特性，就必须使用 Object.defineProperty()方法。用法如下：
```javascript
let person = {}; 
Object.defineProperty(person, "name", { 
 writable: false, 
 value: "Nicholas" 
});
```
##### 访问器属性
访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为：
1. Configurable：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。
2. Enumerable：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。
3. Get：获取函数，在读取属性时调用。默认值为 undefined。
4. Set：设置函数，在写入属性时调用。默认值为 undefined。

访问器属性是不能直接定义的，必须使用 Object defineProperty()。下面是一个例子：
```javascript
let book = { 
 year_: 2017, 
 edition: 1
}; 
Object.defineProperty(book, "year", { 
 get() { 
    return this.year_; 
 }, 
 set(newValue) { 
    if (newValue > 2017) { 
        this.year_ = newValue; 
        this.edition += newValue - 2017; 
    } 
 } 
}); 
book.year = 2018; 
console.log(book.edition); // 2
```
获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。